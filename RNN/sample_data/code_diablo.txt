package d2player

import (
	"image/color"

	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2enum"
	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2gui"
)

type bindingLayout struct {
	wrapperLayout   *d2gui.Layout
	descLayout      *d2gui.Layout
	descLabel       *d2gui.Label
	primaryLayout   *d2gui.Layout
	primaryLabel    *d2gui.Label
	secondaryLayout *d2gui.Layout
	secondaryLabel  *d2gui.Label

	binding   *KeyBinding
	gameEvent d2enum.GameEvent
}

func (l *bindingLayout) setTextAndColor(layout *d2gui.Label, text string, col color.RGBA) error {
	if err := layout.SetText(text); err != nil {
		return err
	}

	if err := layout.SetColor(col); err != nil {
		return err
	}

	return nil
}

func (l *bindingLayout) SetPrimaryBindingTextAndColor(text string, col color.RGBA) error {
	return l.setTextAndColor(l.primaryLabel, text, col)
}

func (l *bindingLayout) SetSecondaryBindingTextAndColor(text string, col color.RGBA) error {
	return l.setTextAndColor(l.secondaryLabel, text, col)
}

func (l *bindingLayout) Reset() error {
	if err := l.descLabel.SetIsHovered(false); err != nil {
		return err
	}

	if err := l.primaryLabel.SetIsHovered(false); err != nil {
		return err
	}

	if err := l.secondaryLabel.SetIsHovered(false); err != nil {
		return err
	}

	l.primaryLabel.SetIsBlinking(false)
	l.secondaryLabel.SetIsBlinking(false)

	return nil
}

func (l *bindingLayout) isInLayoutRect(x, y int, targetLayout *d2gui.Layout) bool {
	targetW, targetH := targetLayout.GetSize()
	targetX, targetY := targetLayout.Sx, targetLayout.Sy

	if x >= targetX && x <= targetX+targetW && y >= targetY && y <= targetY+targetH {
		return true
	}

	return false
}

func (l *bindingLayout) GetPointedLayoutAndLabel(x, y int) (d2enum.GameEvent, KeyBindingType) {
	if l.isInLayoutRect(x, y, l.descLayout) {
		return l.gameEvent, KeyBindingTypePrimary
	}

	if l.primaryLayout != nil {
		if l.isInLayoutRect(x, y, l.primaryLayout) {
			return l.gameEvent, KeyBindingTypePrimary
		}
	}

	if l.secondaryLayout != nil {
		if l.isInLayoutRect(x, y, l.secondaryLayout) {
			return l.gameEvent, KeyBindingTypeSecondary
		}
	}

	return defaultGameEvent, KeyBindingTypeNone
}
package d2player

import (
	"fmt"
	"image"

	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2interface"
	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2resource"
	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2util"
	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2asset"
	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2ui"
)

type globeType = int

const (
	typeHealthGlobe globeType = iota
	typeManaGlobe
)

const (
	globeHeight = 80
	globeWidth  = 80

	globeSpriteOffsetX = 28
	globeSpriteOffsetY = -5

	healthStatusOffsetX = 30
	healthStatusOffsetY = -13

	manaStatusOffsetX = 7
	manaStatusOffsetY = -12

	manaGlobeScreenOffsetX = 117

	hpLabelX = 15
	hpLabelY = 487

	manaLabelX = 785
	manaLabelY = 487
)

// static check that globeWidget implements Widget
var _ d2ui.Widget = &globeWidget{}

// static check that globeWidget implements ClickableWidget
var _ d2ui.ClickableWidget = &globeWidget{}

type globeFrame struct {
	sprite  *d2ui.Sprite
	offsetX int
	offsetY int
	idx     int
	gw      *globeWidget
}

func (gf *globeFrame) setFrameIndex() {
	if err := gf.sprite.SetCurrentFrame(gf.idx); err != nil {
		gf.gw.Error(err.Error())
	}
}

func (gf *globeFrame) setPosition(x, y int) {
	gf.sprite.SetPosition(x+gf.offsetX, y+gf.offsetY)
}

func newGlobeWidget(ui *d2ui.UIManager,
	asset *d2asset.AssetManager,
	x, y int,
	gtype globeType,
	value, valueMax *int,
	l d2util.LogLevel) *globeWidget {
	var globe, overlap *globeFrame

	var tooltipX, tooltipY int

	var tooltipTrans string

	base := d2ui.NewBaseWidget(ui)
	base.SetPosition(x, y)

	if gtype == typeHealthGlobe {
		globe = &globeFrame{
			offsetX: healthStatusOffsetX,
			offsetY: healthStatusOffsetY,
			idx:     frameHealthStatus,
		}
		overlap = &globeFrame{
			offsetX: globeSpriteOffsetX,
			offsetY: globeSpriteOffsetY,
			idx:     frameHealthStatus,
		}
		tooltipX, tooltipY = hpLabelX, hpLabelY
		tooltipTrans = "panelhealth"
	} else if gtype == typeManaGlobe {
		globe = &globeFrame{
			offsetX: manaStatusOffsetX,
			offsetY: manaStatusOffsetY,
			idx:     frameManaStatus,
		}
		overlap = &globeFrame{
			offsetX: rightGlobeOffsetX,
			offsetY: rightGlobeOffsetY,
			idx:     frameRightGlobe,
		}
		tooltipX, tooltipY = manaLabelX, manaLabelY
		tooltipTrans = "panelmana"
	}

	gw := &globeWidget{
		BaseWidget:      base,
		asset:           asset,
		value:           value,
		valueMax:        valueMax,
		globe:           globe,
		overlap:         overlap,
		isTooltipLocked: false,
		tooltipX:        tooltipX,
		tooltipY:        tooltipY,
		tooltipTrans:    tooltipTrans,
	}

	gw.OnHoverStart(func() {
		if !gw.isTooltipLocked {
			gw.tooltip.SetVisible(true)
		}
	})

	gw.OnHoverEnd(func() {
		if !gw.isTooltipLocked {
			gw.tooltip.SetVisible(false)
		}
	})

	gw.Logger = d2util.NewLogger()
	gw.Logger.SetLevel(l)
	gw.Logger.SetPrefix(logPrefix)

	return gw
}

type globeWidget struct {
	*d2ui.BaseWidget
	asset    *d2asset.AssetManager
	value    *int
	valueMax *int
	globe    *globeFrame
	overlap  *globeFrame
	*d2util.Logger

	pressed         bool
	isTooltipLocked bool
	tooltip         *d2ui.Tooltip
	tooltipX        int
	tooltipY        int
	tooltipTrans    string
}

func (g *globeWidget) load() {
	var err error

	g.globe.sprite, err = g.GetManager().NewSprite(d2resource.HealthManaIndicator, d2resource.PaletteSky)
	if err != nil {
		g.Error(err.Error())
	}

	g.globe.setFrameIndex()

	g.overlap.sprite, err = g.GetManager().NewSprite(d2resource.GameGlobeOverlap, d2resource.PaletteSky)
	if err != nil {
		g.Error(err.Error())
	}

	g.overlap.setFrameIndex()

	// tooltip
	g.tooltip = g.GetManager().NewTooltip(d2resource.Font16, d2resource.PaletteUnits, d2ui.TooltipXLeft, d2ui.TooltipYTop)
	g.tooltip.SetPosition(g.tooltipX, g.tooltipY)
	g.tooltip.SetBoxEnabled(false)
}

// Render draws the widget to the screen
func (g *globeWidget) Render(target d2interface.Surface) {
	valuePercent := float64(*g.value) / float64(*g.valueMax)
	barHeight := int(valuePercent * float64(globeHeight))

	maskRect := image.Rect(0, globeHeight-barHeight, globeWidth, globeHeight)

	g.globe.setPosition(g.GetPosition())
	g.globe.sprite.RenderSection(target, maskRect)

	g.overlap.setPosition(g.GetPosition())
	g.overlap.sprite.Render(target)
}

// Contains is special here as the point of origin is at the lower left corner
// in contrast to any other element which is top left.
func (g *globeWidget) Contains(px, py int) bool {
	wx, wy := g.globe.sprite.GetPosition()
	width, height := g.globe.sprite.GetSize()

	return px >= wx && px <= wx+width && py <= wy && py >= wy-height
}

func (g *globeWidget) updateTooltip() {
	// Create and format string from string lookup table.
	fmtStr := g.asset.TranslateString(g.tooltipTrans)
	strPanel := fmt.Sprintf(fmtStr, *g.value, *g.valueMax)
	g.tooltip.SetText(strPanel)
}

func (g *globeWidget) Advance(elapsed float64) error {
	g.updateTooltip()

	return nil
}

func (g *globeWidget) Activate() {
	g.isTooltipLocked = !g.isTooltipLocked
	g.tooltip.SetVisible(g.isTooltipLocked)
}

func (g *globeWidget) GetEnabled() bool {
	return true
}

func (g *globeWidget) SetEnabled(enable bool) {
	// No-op
}

func (g *globeWidget) GetPressed() bool {
	return g.pressed
}

func (g *globeWidget) SetPressed(pressed bool) {
	g.pressed = pressed
}

func (g *globeWidget) OnActivated(callback func()) {
	// No-op
}
package d2player

import (
	"fmt"

	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2records"

	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2enum"
	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2interface"
	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2resource"
	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2util"
	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2asset"
	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2item/diablo2item"
	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2ui"
)

const (
	frameInventoryTopLeft     = 4
	frameInventoryTopRight    = 5
	frameInventoryBottomLeft  = 6
	frameInventoryBottomRight = 7
)

const (
	invCloseButtonX, invCloseButtonY = 419, 449
	invGoldButtonX, invGoldButtonY   = 485, 455
	invGoldLabelX, invGoldLabelY     = 510, 455
)

// NewInventory creates an inventory instance and returns a pointer to it
func NewInventory(asset *d2asset.AssetManager,
	ui *d2ui.UIManager,
	l d2util.LogLevel,
	gold int,
	record *d2records.InventoryRecord) (*Inventory, error) {
	itemTooltip := ui.NewTooltip(d2resource.FontFormal11, d2resource.PaletteStatic, d2ui.TooltipXCenter, d2ui.TooltipYBottom)

	itemFactory, err := diablo2item.NewItemFactory(asset)
	if err != nil {
		return nil, fmt.Errorf("during creating new item factory: %s", err)
	}

	mgp := NewMoveGoldPanel(asset, ui, gold, l)

	inventory := &Inventory{
		asset:       asset,
		uiManager:   ui,
		item:        itemFactory,
		grid:        NewItemGrid(asset, ui, l, record),
		originX:     record.Panel.Left,
		itemTooltip: itemTooltip,
		// originY: record.Panel.Top,
		originY:       0, // expansion data has these all offset by +60 ...
		gold:          gold,
		moveGoldPanel: mgp,
	}

	inventory.moveGoldPanel.SetOnCloseCb(func() { inventory.onCloseGoldPanel() })

	inventory.Logger = d2util.NewLogger()
	inventory.Logger.SetLevel(l)
	inventory.Logger.SetPrefix(logPrefix)

	return inventory, nil
}

// Inventory represents the inventory
type Inventory struct {
	asset         *d2asset.AssetManager
	item          *diablo2item.ItemFactory
	uiManager     *d2ui.UIManager
	panel         *d2ui.Sprite
	goldLabel     *d2ui.Label
	grid          *ItemGrid
	itemTooltip   *d2ui.Tooltip
	panelGroup    *d2ui.WidgetGroup
	hoverX        int
	hoverY        int
	originX       int
	originY       int
	lastMouseX    int
	lastMouseY    int
	hovering      bool
	isOpen        bool
	onCloseCb     func()
	gold          int
	moveGoldPanel *MoveGoldPanel

	*d2util.Logger
}

// Toggle negates the open state of the inventory
func (g *Inventory) Toggle() {
	if g.isOpen {
		g.Close()
	} else {
		g.Open()
	}
}

// Load the resources required by the inventory
func (g *Inventory) Load() {
	var err error

	g.panelGroup = g.uiManager.NewWidgetGroup(d2ui.RenderPriorityInventory)

	frame := g.uiManager.NewUIFrame(d2ui.FrameRight)
	g.panelGroup.AddWidget(frame)

	g.panel, err = g.uiManager.NewSprite(d2resource.InventoryCharacterPanel, d2resource.PaletteSky)
	if err != nil {
		g.Error(err.Error())
	}

	closeButton := g.uiManager.NewButton(d2ui.ButtonTypeSquareClose, "")
	closeButton.SetVisible(false)
	closeButton.SetPosition(invCloseButtonX, invCloseButtonY)
	closeButton.OnActivated(func() { g.Close() })
	g.panelGroup.AddWidget(closeButton)

	goldButton := g.uiManager.NewButton(d2ui.ButtonTypeGoldCoin, "")
	goldButton.SetVisible(false)
	goldButton.SetPosition(invGoldButtonX, invGoldButtonY)
	goldButton.OnActivated(func() { g.onGoldClicked() })

	// nolint:gocritic // this variable will be used in future
	// deposite := g.asset.TranslateString("strGoldDeposit")
	drop := g.asset.TranslateString("strGoldDrop")
	// nolint:gocritic // this variable will be used in future
	// withdraw := g.asset.TranslateString("strGoldWithdraw")

	tooltip := g.uiManager.NewTooltip(d2resource.Font16, d2resource.PaletteSky, d2ui.TooltipXCenter, d2ui.TooltipYBottom)
	// here should be switch-case statement for each of move-gold button descr
	tooltip.SetText(drop)
	tooltip.SetPosition(invGoldButtonX, invGoldButtonY)
	goldButton.SetTooltip(tooltip)

	g.panelGroup.AddWidget(goldButton)

	g.goldLabel = g.uiManager.NewLabel(d2resource.Font16, d2resource.PaletteStatic)
	g.goldLabel.Alignment = d2ui.HorizontalAlignLeft
	g.goldLabel.SetText(fmt.Sprintln(g.moveGoldPanel.gold))
	g.goldLabel.SetPosition(invGoldLabelX, invGoldLabelY)
	g.panelGroup.AddWidget(g.goldLabel)

	// https://github.com/OpenDiablo2/OpenDiablo2/issues/795
	testInventoryCodes := [][]string{
		{"kit", "Crimson", "of the Bat", "of Frost"},
		{"rin", "Steel", "of Shock"},
		{"jav"},
		{"buc"},
	}

	inventoryItems := make([]InventoryItem, 0)

	for idx := range testInventoryCodes {
		item, itemErr := g.item.NewItem(testInventoryCodes[idx]...)
		if itemErr != nil {
			continue
		}

		item.Identify()
		inventoryItems = append(inventoryItems, item)
	}

	// https://github.com/OpenDiablo2/OpenDiablo2/issues/795
	testEquippedItemCodes := map[d2enum.EquippedSlot][]string{
		d2enum.EquippedSlotLeftArm:   {"wnd"},
		d2enum.EquippedSlotRightArm:  {"buc"},
		d2enum.EquippedSlotHead:      {"crn"},
		d2enum.EquippedSlotTorso:     {"plt"},
		d2enum.EquippedSlotLegs:      {"vbt"},
		d2enum.EquippedSlotBelt:      {"vbl"},
		d2enum.EquippedSlotGloves:    {"lgl"},
		d2enum.EquippedSlotLeftHand:  {"rin"},
		d2enum.EquippedSlotRightHand: {"rin"},
		d2enum.EquippedSlotNeck:      {"amu"},
	}

	for slot := range testEquippedItemCodes {
		item, itemErr := g.item.NewItem(testEquippedItemCodes[slot]...)
		if itemErr != nil {
			continue
		}

		g.grid.ChangeEquippedSlot(slot, item)
	}

	_, err = g.grid.Add(inventoryItems...)
	if err != nil {
		g.Errorf("could not add items to the inventory, err: %v", err.Error())
	}

	g.moveGoldPanel.Load()

	g.panelGroup.SetVisible(false)
}

// Open opens the inventory
func (g *Inventory) Open() {
	g.isOpen = true
	g.panelGroup.SetVisible(true)
}

// Close closes the inventory
func (g *Inventory) Close() {
	g.isOpen = false
	g.moveGoldPanel.Close()
	g.panelGroup.SetVisible(false)
	g.itemTooltip.SetVisible(false)
	g.onCloseCb()
}

// SetOnCloseCb the callback run on closing the inventory
func (g *Inventory) SetOnCloseCb(cb func()) {
	g.onCloseCb = cb
}

func (g *Inventory) onGoldClicked() {
	g.Info("Move gold action clicked")
	g.toggleMoveGoldPanel()
}

func (g *Inventory) toggleMoveGoldPanel() {
	g.moveGoldPanel.Toggle()
}

func (g *Inventory) onCloseGoldPanel() {

}

// IsOpen returns true if the inventory is open
func (g *Inventory) IsOpen() bool {
	return g.isOpen
}

// Advance advances the state of the Inventory
func (g *Inventory) Advance(_ float64) {
	if !g.IsOpen() {
		return
	}

	g.goldLabel.SetText(fmt.Sprintln(g.moveGoldPanel.gold))
}

// Render draws the inventory onto the given surface
func (g *Inventory) Render(target d2interface.Surface) {
	if !g.isOpen {
		return
	}

	g.renderFrame(target)

	g.grid.Render(target)
	g.showItemDescriptionTooltip()
}

func (g *Inventory) renderFrame(target d2interface.Surface) {
	frames := []int{
		frameInventoryTopLeft,
		frameInventoryTopRight,
		frameInventoryBottomRight,
		frameInventoryBottomLeft,
	}

	x, y := g.originX+1, g.originY
	y += 64

	for _, frame := range frames {
		if err := g.panel.SetCurrentFrame(frame); err != nil {
			g.Error(err.Error())
			return
		}

		w, h := g.panel.GetCurrentFrameSize()

		g.panel.SetPosition(x, y+h)
		g.panel.Render(target)

		switch frame {
		case frameInventoryTopLeft:
			x += w
		case frameInventoryTopRight:
			y += h
		case frameInventoryBottomRight:
			x = g.originX + 1
		}
	}
}

func (g *Inventory) showItemDescriptionTooltip() {
	hoveringNow := g.checkEquippedSlotsHover()

	if hoveringNow {
		g.hovering = true
		return
	}

	hoveringNow = g.checkGridSlotsHover()

	if !hoveringNow {
		g.itemTooltip.SetVisible(false)
	}

	g.hovering = hoveringNow
}

func (g *Inventory) checkGridSlotsHover() bool {
	hovering := false

	for idx := range g.grid.items {
		item := g.grid.items[idx]
		ix, iy := g.grid.SlotToScreen(item.InventoryGridSlot())
		iw, ih := g.grid.sprites[item.GetItemCode()].GetCurrentFrameSize()
		mx, my := g.lastMouseX, g.lastMouseY
		hovering = hovering || ((mx > ix) && (mx < ix+iw) && (my > iy) && (my < iy+ih))

		if hovering {
			if !g.hovering {
				// set the initial hover coordinates
				// this is so that moving mouse doesnt move the description
				g.hoverX, g.hoverY = mx, my
			}

			g.showGridItemDescriptionTooltip(item)

			break
		}
	}

	return hovering
}

func (g *Inventory) checkEquippedSlotsHover() bool {
	hovering := false

	for _, slot := range g.grid.equipmentSlots {
		mx, my := g.lastMouseX, g.lastMouseY

		hovering = hovering || ((mx > slot.x) && (mx < slot.x+slot.width) && (my < slot.y) && (my > slot.y-slot.height))
		if hovering {
			if !g.hovering {
				g.hoverX, g.hoverY = mx, my
			}

			g.showEquippedItemDescriptionTooltip(slot)

			break
		}
	}

	return hovering
}

func (g *Inventory) showGridItemDescriptionTooltip(i InventoryItem) {
	if !g.moveGoldPanel.IsOpen() {
		lines := i.GetItemDescription()
		g.itemTooltip.SetTextLines(lines)
		_, y := g.grid.SlotToScreen(i.InventoryGridSlot())

		g.itemTooltip.SetPosition(g.hoverX, y)
		g.itemTooltip.SetVisible(true)
	}
}

func (g *Inventory) showEquippedItemDescriptionTooltip(slot EquipmentSlot) {
	if !g.moveGoldPanel.IsOpen() {
		lines := slot.item.GetItemDescription()
		g.itemTooltip.SetTextLines(lines)
		g.itemTooltip.SetPosition(g.hoverX, slot.y)
		g.itemTooltip.SetVisible(true)
	}
}
package d2player

import (
	"log"
	"strconv"

	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2enum"
	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2geom"
	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2interface"
	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2resource"
	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2util"
	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2asset"
	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2hero"
	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2map/d2mapentity"
	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2ui"
)

const (
	lightGreen = 0x18ff00ff
	red        = 0xff0000ff
	lightRed   = 0xdb3f3dff
	orange     = 0xffa800ff
)

const ( // for the dc6 frames
	partyPanelTopLeft = iota
	partyPanelTopRight
	partyPanelBottomLeft
	partyPanelBottomRight
)

const ( // for bar's dc6 frames
	barLeft = iota
	barRight
)

const (
	partyPanelOffsetX, partyPanelOffsetY = 80, 64
)

const (
	partyPanelCloseButtonX, partyPanelCloseButtonY = 358, 453
	partyPanelHeroNameX, partyPanelHeroNameY       = 180, 80
)

const (
	buttonSize = 19
)

const (
	barX, baseBarY                                   = 90, 134
	relationshipSwitcherX, baseRelationshipSwitcherY = 95, 150
	listeningSwitcherX, baseListeningSwitcherY       = 342, 140
	seeingSwitcherX, baseSeeingSwitcherY             = 365, 140
	nameLabelX, baseNameLabelY                       = 115, 144
	nameTooltipX, baseNameTooltipY                   = 100, 120
	classLabelX, baseClassLabelY                     = 115, 158
	levelLabelX, baseLevelLabelY                     = 386, 160
	inviteAcceptButtonX, baseInviteAcceptButtonY     = 265, 147
	indexOffset                                      = 52
)

// NewPartyPanel creates a new party panel
func NewPartyPanel(asset *d2asset.AssetManager,
	ui *d2ui.UIManager,
	heroName string,
	l d2util.LogLevel,
	me *d2mapentity.Player,
	heroState *d2hero.HeroStatsState,
	players map[string]*d2mapentity.Player) *PartyPanel {
	log.Print("OpenDiablo2 - Party Panel - development")

	originX := 0
	originY := 0

	pp := &PartyPanel{
		asset:     asset,
		uiManager: ui,
		originX:   originX,
		originY:   originY,
		heroState: heroState,
		heroName:  heroName,
		labels:    &StatsPanelLabels{},
		barX:      barX,
		barY:      baseBarY,
		players:   players,
		me:        me,
	}

	var partyIndexes [d2enum.MaxPlayersInGame]*partyIndex

	var indexes [d2enum.MaxPlayersInGame]*d2ui.WidgetGroup

	for i := 0; i < d2enum.MaxPlayersInGame; i++ {
		partyIndexes[i] = pp.newPartyIndex()
		indexes[i] = pp.uiManager.NewWidgetGroup(d2ui.RenderPriorityHeroStatsPanel)
	}

	pp.partyIndexes = partyIndexes
	pp.indexes = indexes

	pp.Logger = d2util.NewLogger()
	pp.Logger.SetLevel(l)
	pp.Logger.SetPrefix(logPrefix)

	return pp
}

// PartyPanel represents the party panel
type PartyPanel struct {
	asset      *d2asset.AssetManager
	uiManager  *d2ui.UIManager
	panel      *d2ui.Sprite
	bar        *d2ui.Sprite
	heroState  *d2hero.HeroStatsState
	heroName   string
	labels     *StatsPanelLabels
	onCloseCb  func()
	panelGroup *d2ui.WidgetGroup

	partyIndexes [d2enum.MaxPlayersInGame]*partyIndex
	indexes      [d2enum.MaxPlayersInGame]*d2ui.WidgetGroup

	players map[string]*d2mapentity.Player
	me      *d2mapentity.Player

	originX int
	originY int
	isOpen  bool
	barX    int
	barY    int

	*d2util.Logger
}

// newPartyIndex creates new party index
func (s *PartyPanel) newPartyIndex() *partyIndex {
	result := &partyIndex{
		asset: s.asset,
		me:    s.me,
	}

	nameLabel := s.uiManager.NewLabel(d2resource.Font16, d2resource.PaletteSky)
	result.nameTooltip = s.uiManager.NewTooltip(d2resource.Font16, d2resource.PaletteSky, d2ui.TooltipXCenter, d2ui.TooltipYTop)
	result.name = nameLabel

	classLabel := s.uiManager.NewLabel(d2resource.Font16, d2resource.PaletteSky)
	result.class = classLabel

	result.nameRect = d2geom.Rectangle{}

	levelLabel := s.uiManager.NewLabel(d2resource.Font16, d2resource.PaletteSky)
	levelLabel.Alignment = d2ui.HorizontalAlignRight
	result.level = levelLabel

	relationships := s.createSwitcher(d2enum.PartyButtonRelationshipsFrame)
	relationships.SetDisabledColor(lightRed)

	result.relationshipsActiveTooltip = s.uiManager.NewTooltip(d2resource.Font16, d2resource.PaletteSky, d2ui.TooltipXCenter, d2ui.TooltipYTop)
	result.relationshipsActiveTooltip.SetText(s.asset.TranslateString("strParty7") + "\n" + s.asset.TranslateString("strParty8"))
	relationships.SetActiveTooltip(result.relationshipsActiveTooltip)

	result.relationshipsInactiveTooltip = s.uiManager.NewTooltip(d2resource.Font16, d2resource.PaletteSky,
		d2ui.TooltipXCenter, d2ui.TooltipYTop)
	result.relationshipsInactiveTooltip.SetText(s.asset.TranslateString("strParty9") + "\n" + s.asset.TranslateString("strParty8"))
	relationships.SetInactiveTooltip(result.relationshipsInactiveTooltip)

	result.relationshipSwitcher = relationships

	seeing := s.createSwitcher(d2enum.PartyButtonSeeingFrame)

	result.seeingActiveTooltip = s.uiManager.NewTooltip(d2resource.Font16, d2resource.PaletteSky, d2ui.TooltipXCenter, d2ui.TooltipYTop)
	result.seeingActiveTooltip.SetText(s.asset.TranslateString("strParty19"))
	seeing.SetActiveTooltip(result.seeingActiveTooltip)

	result.seeingInactiveTooltip = s.uiManager.NewTooltip(d2resource.Font16, d2resource.PaletteSky, d2ui.TooltipXCenter, d2ui.TooltipYTop)
	result.seeingInactiveTooltip.SetText(s.asset.TranslateString("strParty22"))
	seeing.SetInactiveTooltip(result.seeingInactiveTooltip)

	result.seeingSwitcher = seeing

	listening := s.createSwitcher(d2enum.PartyButtonListeningFrame)

	result.listeningActiveTooltip = s.uiManager.NewTooltip(d2resource.Font16, d2resource.PaletteSky, d2ui.TooltipXCenter, d2ui.TooltipYTop)
	result.listeningActiveTooltip.SetText(s.asset.TranslateString("strParty17") + "\n" + s.asset.TranslateString("strParty18"))
	listening.SetActiveTooltip(result.listeningActiveTooltip)

	result.listeningInactiveTooltip = s.uiManager.NewTooltip(d2resource.Font16, d2resource.PaletteSky, d2ui.TooltipXCenter, d2ui.TooltipYTop)
	result.listeningInactiveTooltip.SetText(s.asset.TranslateString("strParty11") + "\n" + s.asset.TranslateString("strParty16"))
	listening.SetInactiveTooltip(result.listeningInactiveTooltip)

	result.listeningSwitcher = listening

	result.inviteAcceptButton = s.uiManager.NewButton(d2ui.ButtonTypePartyButton, s.asset.TranslateString("Invite"))
	result.inviteAcceptButton.SetVisible(false)

	return result
}

// partyIndex represents a party index
type partyIndex struct {
	asset *d2asset.AssetManager
	me    *d2mapentity.Player

	hero                         *d2mapentity.Player
	name                         *d2ui.Label
	nameTooltip                  *d2ui.Tooltip
	nameRect                     d2geom.Rectangle
	class                        *d2ui.Label
	level                        *d2ui.Label
	relationshipSwitcher         *d2ui.SwitchableButton
	relationshipsActiveTooltip   *d2ui.Tooltip
	relationshipsInactiveTooltip *d2ui.Tooltip
	seeingSwitcher               *d2ui.SwitchableButton
	seeingActiveTooltip          *d2ui.Tooltip
	seeingInactiveTooltip        *d2ui.Tooltip
	listeningSwitcher            *d2ui.SwitchableButton
	listeningActiveTooltip       *d2ui.Tooltip
	listeningInactiveTooltip     *d2ui.Tooltip
	inviteAcceptButton           *d2ui.Button
	relationships                d2enum.PlayersRelationships
}

func (pi *partyIndex) setNameTooltipText() {
	switch pi.relationships {
	case d2enum.PlayerRelationNeutral, d2enum.PlayerRelationFriend:
		pi.nameTooltip.SetText(pi.asset.TranslateString("Party17"))
	case d2enum.PlayerRelationEnemy:
		pi.nameTooltip.SetText(pi.asset.TranslateString("Party12"))
	}
}

// setColor sets appropriate labels' colors
func (pi *partyIndex) setColor(relations d2enum.PlayersRelationships) {
	color := d2util.Color(white)

	switch relations {
	case d2enum.PlayerRelationEnemy:
		color = d2util.Color(red)

		pi.relationshipSwitcher.SetState(false)
	case d2enum.PlayerRelationFriend:
		color = d2util.Color(lightGreen)
	case d2enum.PlayerRelationNeutral:
		if pi.CanGoHostile() {
			color = d2util.Color(white)
		} else {
			color = d2util.Color(orange)
			pi.relationshipSwitcher.SetEnabled(false)
		}
	}

	pi.name.Color[0] = color
	pi.class.Color[0] = color
	pi.level.Color[0] = color
}

// setPositions sets party-index's position to given
func (pi *partyIndex) setPositions(idx int) {
	var w, h int

	pi.name.SetPosition(nameLabelX, baseNameLabelY+indexOffset*idx)
	pi.nameTooltip.SetPosition(nameTooltipX, baseNameTooltipY+indexOffset*idx)
	pi.class.SetPosition(classLabelX, baseClassLabelY+indexOffset*idx)
	pi.level.SetPosition(levelLabelX, baseLevelLabelY+indexOffset*idx)

	w, h1 := pi.class.GetSize()

	_, h = pi.name.GetSize()

	pi.nameRect = d2geom.Rectangle{
		Left:   nameLabelX,
		Top:    baseNameLabelY + idx*indexOffset,
		Width:  w,
		Height: h + h1,
	}

	pi.relationshipSwitcher.SetPosition(relationshipSwitcherX, baseRelationshipSwitcherY+indexOffset*idx)
	_, h = pi.relationshipsActiveTooltip.GetSize()
	pi.relationshipsActiveTooltip.SetPosition(relationshipSwitcherX+buttonSize, baseRelationshipSwitcherY+idx*indexOffset-h)
	_, h = pi.relationshipsInactiveTooltip.GetSize()
	pi.relationshipsInactiveTooltip.SetPosition(relationshipSwitcherX+buttonSize, baseRelationshipSwitcherY+idx*indexOffset-h)

	pi.seeingSwitcher.SetPosition(seeingSwitcherX, baseSeeingSwitcherY+idx*indexOffset)
	_, h = pi.seeingActiveTooltip.GetSize()
	pi.seeingActiveTooltip.SetPosition(seeingSwitcherX+buttonSize, baseSeeingSwitcherY+idx*indexOffset-h)
	_, h = pi.seeingInactiveTooltip.GetSize()
	pi.seeingInactiveTooltip.SetPosition(seeingSwitcherX+buttonSize, baseSeeingSwitcherY+idx*indexOffset-h)

	pi.listeningSwitcher.SetPosition(listeningSwitcherX, baseListeningSwitcherY+idx*indexOffset)
	_, h = pi.listeningActiveTooltip.GetSize()
	pi.listeningActiveTooltip.SetPosition(listeningSwitcherX+buttonSize, baseListeningSwitcherY+idx*indexOffset-h)
	_, h = pi.listeningInactiveTooltip.GetSize()
	pi.listeningInactiveTooltip.SetPosition(listeningSwitcherX+buttonSize, baseListeningSwitcherY+idx*indexOffset-h)

	pi.inviteAcceptButton.SetPosition(inviteAcceptButtonX, baseInviteAcceptButtonY+idx*indexOffset)
}

func (pi *partyIndex) CanGoHostile() bool {
	return pi.hero.Stats.Level >= d2enum.PlayersHostileLevel && pi.me.Stats.Level >= d2enum.PlayersHostileLevel
}

// Load the data for the hero status panel
func (s *PartyPanel) Load() {
	var err error

	var w, h int

	// create widgetGroups
	s.panelGroup = s.uiManager.NewWidgetGroup(d2ui.RenderPriorityHeroStatsPanel)
	for i := 0; i < d2enum.MaxPlayersInGame; i++ {
		s.indexes[i] = s.uiManager.NewWidgetGroup(d2ui.RenderPriorityHeroStatsPanel)
	}

	// create frame
	frame := s.uiManager.NewUIFrame(d2ui.FrameLeft)
	s.panelGroup.AddWidget(frame)

	s.panel, err = s.uiManager.NewSprite(d2resource.PartyPanel, d2resource.PaletteSky)
	if err != nil {
		s.Error(err.Error())
	}

	// create panel
	w, h = frame.GetSize()
	staticPanel := s.uiManager.NewCustomWidgetCached(s.renderStaticPanelFrames, w, h)
	s.panelGroup.AddWidget(staticPanel)

	// create close button
	closeButton := s.uiManager.NewButton(d2ui.ButtonTypeSquareClose, "")
	closeButton.SetVisible(false)
	closeButton.SetPosition(partyPanelCloseButtonX, partyPanelCloseButtonY)
	closeButton.OnActivated(func() { s.Close() })
	s.panelGroup.AddWidget(closeButton)

	// our name label
	heroName := s.uiManager.NewLabel(d2resource.Font16, d2resource.PaletteSky)
	heroName.SetText(s.heroName)
	heroName.SetPosition(partyPanelHeroNameX, partyPanelHeroNameY)
	heroName.Alignment = d2ui.HorizontalAlignCenter
	s.panelGroup.AddWidget(heroName)

	// create WidgetGroups of party indexes
	for n, i := range s.partyIndexes {
		s.indexes[n].AddWidget(i.name)
		s.indexes[n].AddWidget(i.class)
		s.indexes[n].AddWidget(i.relationshipSwitcher)
		s.indexes[n].AddWidget(i.seeingSwitcher)
		s.indexes[n].AddWidget(i.listeningSwitcher)
		s.indexes[n].AddWidget(i.level)
		s.indexes[n].AddWidget(i.inviteAcceptButton)
	}

	// create bar
	s.bar, err = s.uiManager.NewSprite(d2resource.PartyBar, d2resource.PaletteSky)
	if err != nil {
		s.Error(err.Error())
	}

	w, h = s.bar.GetCurrentFrameSize()
	v := s.uiManager.NewCustomWidget(s.renderBar, w, h)
	s.panelGroup.AddWidget(v)

	s.setBarPosition()

	s.panelGroup.SetVisible(false)
}

// createSwitcher creates party-panel switcher using frame given
func (s *PartyPanel) createSwitcher(frame int) *d2ui.SwitchableButton {
	active := s.uiManager.NewDefaultButton(d2resource.PartyBoxes, frame)
	inactive := s.uiManager.NewDefaultButton(d2resource.PartyBoxes, frame+d2enum.PartyButtonNextButtonFrame)
	switcher := s.uiManager.NewSwitchableButton(active, inactive, true)
	switcher.SetVisible(false)

	return switcher
}

// IsOpen returns true if the hero status panel is open
func (s *PartyPanel) IsOpen() bool {
	return s.isOpen
}

// Toggle toggles the visibility of the hero status panel
func (s *PartyPanel) Toggle() {
	if s.isOpen {
		s.Close()
	} else {
		s.Open()
	}
}

// Open opens the hero status panel
func (s *PartyPanel) Open() {
	s.isOpen = true
	s.panelGroup.SetVisible(true)

	for n, i := range s.indexes {
		if s.partyIndexes[n].hero != nil {
			i.SetVisible(true)
		}
	}
}

// Close closed the hero status panel
func (s *PartyPanel) Close() {
	s.isOpen = false
	s.panelGroup.SetVisible(false)

	for _, i := range s.indexes {
		i.SetVisible(false)
	}
}

// SetOnCloseCb the callback run on closing the PartyPanel
func (s *PartyPanel) SetOnCloseCb(cb func()) {
	s.onCloseCb = cb
}

// AddPlayer adds a new player to the party panel
func (s *PartyPanel) AddPlayer(player *d2mapentity.Player, relations d2enum.PlayersRelationships) {
	idx := 0

	// search for free index
	for n, i := range s.partyIndexes {
		if i.hero == nil {
			idx = n
			break
		}
	}

	s.partyIndexes[idx].hero = player

	s.partyIndexes[idx].name.SetText(player.Name())

	s.partyIndexes[idx].class.SetText(s.asset.TranslateString(player.Class.String()))

	s.partyIndexes[idx].level.SetText(s.asset.TranslateString("Level") + ":" + strconv.Itoa(player.Stats.Level))

	s.partyIndexes[idx].relationships = relations

	s.partyIndexes[idx].setColor(relations)

	s.partyIndexes[idx].setPositions(idx)

	s.partyIndexes[idx].setNameTooltipText()
}

// DeletePlayer deletes player from PartyIndexes
func (s *PartyPanel) DeletePlayer(player *d2mapentity.Player) bool {
	for n, i := range s.partyIndexes {
		if i.hero == player {
			s.Debugf("removing player at index %d", n)

			s.partyIndexes[n].hero = nil
			s.Sort()

			return true
		}
	}

	return false
}

// Sort sorts party indexes
func (s *PartyPanel) Sort() {
	var emptySlots []*partyIndex

	var emptySlotsNumbers []int

	var fullSlots []*partyIndex

	var fullSlotsNumbers []int

	// split s.partyIndexes to empty and non-empty
	for n, i := range s.partyIndexes {
		if i.hero == nil {
			emptySlots = append(emptySlots, i)
			emptySlotsNumbers = append(emptySlotsNumbers, n)
		} else {
			fullSlots = append(fullSlots, i)
			fullSlotsNumbers = append(fullSlotsNumbers, n)
		}
	}

	// adds non-empty indexes befor empty indexes
	for n, i := range fullSlots {
		s.partyIndexes[n] = i
	}

	// adds empty indexes
	for n, i := range emptySlots {
		s.partyIndexes[len(fullSlots)+n] = i
	}

	// sorts widget groups
	var sortedWG [d2enum.MaxPlayersInGame]*d2ui.WidgetGroup
	// first add non empty WG's
	for n, i := range fullSlotsNumbers {
		sortedWG[n] = s.indexes[i]
	}

	// after that, adds empty WG's
	for n, i := range emptySlotsNumbers {
		sortedWG[len(fullSlotsNumbers)+n] = s.indexes[i]
	}

	// overwrite existing order
	s.indexes = sortedWG

	// sets appropriate positions
	for n, i := range s.partyIndexes {
		if i.hero != nil {
			i.setPositions(n)
		}
	}
}

// IsInPanel returns true if player given already exists in panel
func (s *PartyPanel) IsInPanel(player *d2mapentity.Player) bool {
	for _, i := range s.partyIndexes {
		if i.hero == player {
			return true
		}
	}

	return false
}

// IsMe returns true if player given is "me"
func (s *PartyPanel) IsMe(player *d2mapentity.Player) bool {
	return player == s.me
}

// setBarPosition sets party-panel bar's position
func (s *PartyPanel) setBarPosition() {
	for n, i := range s.partyIndexes {
		currentN := n

		if i.hero == nil {
			s.barX, s.barY = barX, baseBarY+currentN*indexOffset
			break
		}
	}
}

// UpdatePanel updates panel indexes with players list
func (s *PartyPanel) UpdatePanel() {
	for _, i := range s.players {
		if !s.IsInPanel(i) && !s.IsMe(i) {
			s.AddPlayer(i, d2enum.PlayerRelationNeutral)

			// we need to switch all hidden widgets to be visible
			// s.Open contains appropriate code to do that.
			if s.IsOpen() {
				s.Open()
			}
		}
	}
}

// UpdatePlayersList updates internal players list
func (s *PartyPanel) UpdatePlayersList(list map[string]*d2mapentity.Player) {
	s.players = list
}

// Advance advances panel
func (s *PartyPanel) Advance(_ float64) {
	if !s.IsOpen() {
		return
	}

	s.UpdatePanel()
}

// OnMouseMove handles mouse movement events
func (s *PartyPanel) OnMouseMove(event d2interface.MouseMoveEvent) bool {
	mx, my := event.X(), event.Y()

	for _, i := range s.partyIndexes {
		// Mouse over a game control element
		if i.nameRect.IsInRect(mx, my) {
			i.nameTooltip.SetVisible(true)
		} else {
			i.nameTooltip.SetVisible(false)
		}
	}

	return true
}

// nolint:dupl // see quest_log.go.renderStaticPanelFrames comment
func (s *PartyPanel) renderStaticPanelFrames(target d2interface.Surface) {
	frames := []int{
		partyPanelTopLeft,
		partyPanelTopRight,
		partyPanelBottomRight,
		partyPanelBottomLeft,
	}

	currentX := s.originX + partyPanelOffsetX
	currentY := s.originY + partyPanelOffsetY

	for _, frameIndex := range frames {
		if err := s.panel.SetCurrentFrame(frameIndex); err != nil {
			s.Error(err.Error())
		}

		w, h := s.panel.GetCurrentFrameSize()

		switch frameIndex {
		case statsPanelTopLeft:
			s.panel.SetPosition(currentX, currentY+h)
			currentX += w
		case statsPanelTopRight:
			s.panel.SetPosition(currentX, currentY+h)
			currentY += h
		case statsPanelBottomRight:
			s.panel.SetPosition(currentX, currentY+h)
		case statsPanelBottomLeft:
			s.panel.SetPosition(currentX-w, currentY+h)
		}

		s.panel.Render(target)
	}
}

// renderBar renders party panel's bar
func (s *PartyPanel) renderBar(target d2interface.Surface) {
	frames := []int{
		barLeft,
		barRight,
	}

	currentX := s.originX + s.barX
	currentY := s.originY + s.barY

	for _, frameIndex := range frames {
		if err := s.bar.SetCurrentFrame(frameIndex); err != nil {
			s.Error(err.Error())
		}

		w, h := s.bar.GetCurrentFrameSize()

		switch frameIndex {
		case statsPanelTopLeft:
			s.bar.SetPosition(currentX, currentY)
			currentX += w
		case statsPanelTopRight:
			s.bar.SetPosition(currentX, currentY)
			currentY += h
		}

		s.bar.Render(target)
	}
}
package ebiten

import (
	"fmt"
	"image"
	"image/color"
	"math"

	"github.com/hajimehoshi/ebiten/v2"
	"github.com/hajimehoshi/ebiten/v2/ebitenutil"

	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2enum"
	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2interface"
	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2ui"
)

// static check that we implement our interface
var _ d2interface.Surface = &ebitenSurface{}

const (
	maxAlpha       = 0xff
	cacheLimit     = 512
	transparency25 = 0.25
	transparency50 = 0.50
	transparency75 = 0.75
)

type colorMCacheKey uint32

type colorMCacheEntry struct {
	colorMatrix ebiten.ColorM
	atime       int64
}

type ebitenSurface struct {
	renderer       *Renderer
	stateStack     []surfaceState
	stateCurrent   surfaceState
	image          *ebiten.Image
	colorMCache    map[colorMCacheKey]*colorMCacheEntry
	monotonicClock int64
}

func createEbitenSurface(r *Renderer, img *ebiten.Image, currentState ...surfaceState) *ebitenSurface {
	state := surfaceState{
		effect:     d2enum.DrawEffectNone,
		saturation: defaultSaturation,
		brightness: defaultBrightness,
		skewX:      defaultSkewX,
		skewY:      defaultSkewY,
		scaleX:     defaultScaleX,
		scaleY:     defaultScaleY,
	}
	if len(currentState) > 0 {
		state = currentState[0]
	}

	return &ebitenSurface{
		renderer:     r,
		image:        img,
		stateCurrent: state,
		colorMCache:  make(map[colorMCacheKey]*colorMCacheEntry),
	}
}

// Renderer returns the renderer
func (s *ebitenSurface) Renderer() d2interface.Renderer {
	return s.renderer
}

// PushTranslation pushes an x,y translation to the state stack
func (s *ebitenSurface) PushTranslation(x, y int) {
	s.stateStack = append(s.stateStack, s.stateCurrent)
	s.stateCurrent.x += x
	s.stateCurrent.y += y
}

// PushSkew pushes a skew to the state stack
func (s *ebitenSurface) PushSkew(skewX, skewY float64) {
	s.stateStack = append(s.stateStack, s.stateCurrent)
	s.stateCurrent.skewX = skewX
	s.stateCurrent.skewY = skewY
}

// PushScale pushes a scale to the state stack
func (s *ebitenSurface) PushScale(scaleX, scaleY float64) {
	s.stateStack = append(s.stateStack, s.stateCurrent)
	s.stateCurrent.scaleX = scaleX
	s.stateCurrent.scaleY = scaleY
}

// PushEffect pushes an effect to the state stack
func (s *ebitenSurface) PushEffect(effect d2enum.DrawEffect) {
	s.stateStack = append(s.stateStack, s.stateCurrent)
	s.stateCurrent.effect = effect
}

// PushFilter pushes a filter to the state stack
func (s *ebitenSurface) PushFilter(filter d2enum.Filter) {
	s.stateStack = append(s.stateStack, s.stateCurrent)
	s.stateCurrent.filter = d2ToEbitenFilter(filter)
}

// PushColor pushes a color to the stat stack
func (s *ebitenSurface) PushColor(c color.Color) {
	s.stateStack = append(s.stateStack, s.stateCurrent)
	s.stateCurrent.color = c
}

// PushBrightness pushes a brightness value to the state stack
func (s *ebitenSurface) PushBrightness(brightness float64) {
	s.stateStack = append(s.stateStack, s.stateCurrent)
	s.stateCurrent.brightness = brightness
}

// PushSaturation pushes a saturation value to the state stack
func (s *ebitenSurface) PushSaturation(saturation float64) {
	s.stateStack = append(s.stateStack, s.stateCurrent)
	s.stateCurrent.saturation = saturation
}

// Pop pops a state off of the state stack
func (s *ebitenSurface) Pop() {
	count := len(s.stateStack)
	if count == 0 {
		panic("empty stack")
	}

	s.stateCurrent = s.stateStack[count-1]
	s.stateStack = s.stateStack[:count-1]
}

// PopN pops n states off the the state stack
func (s *ebitenSurface) PopN(n int) {
	for i := 0; i < n; i++ {
		s.Pop()
	}
}

func (s *ebitenSurface) RenderSprite(sprite *d2ui.Sprite) {
	opts := s.createDrawImageOptions()

	if s.stateCurrent.brightness != 1 || s.stateCurrent.saturation != 1 {
		opts.ColorM.ChangeHSV(0, s.stateCurrent.saturation, s.stateCurrent.brightness)
	}

	s.handleStateEffect(opts)

	sprite.Render(s)
}

// Render renders the given surface
func (s *ebitenSurface) Render(sfc d2interface.Surface) {
	opts := s.createDrawImageOptions()

	if s.stateCurrent.brightness != 1 || s.stateCurrent.saturation != 1 {
		opts.ColorM.ChangeHSV(0, s.stateCurrent.saturation, s.stateCurrent.brightness)
	}

	s.handleStateEffect(opts)

	s.image.DrawImage(sfc.(*ebitenSurface).image, opts)
}

// Renders the section of the surface, given the bounds
func (s *ebitenSurface) RenderSection(sfc d2interface.Surface, bound image.Rectangle) {
	opts := s.createDrawImageOptions()

	if s.stateCurrent.brightness != 0 {
		opts.ColorM.ChangeHSV(0, s.stateCurrent.saturation, s.stateCurrent.brightness)
	}

	s.handleStateEffect(opts)

	s.image.DrawImage(sfc.(*ebitenSurface).image.SubImage(bound).(*ebiten.Image), opts)
}

func (s *ebitenSurface) createDrawImageOptions() *ebiten.DrawImageOptions {
	opts := &ebiten.DrawImageOptions{}

	if s.stateCurrent.skewX != 0 || s.stateCurrent.skewY != 0 {
		opts.GeoM.Skew(s.stateCurrent.skewX, s.stateCurrent.skewY)
	}

	if s.stateCurrent.scaleX != 1.0 || s.stateCurrent.scaleY != 1.0 {
		opts.GeoM.Scale(s.stateCurrent.scaleX, s.stateCurrent.scaleY)
	}

	opts.GeoM.Translate(float64(s.stateCurrent.x), float64(s.stateCurrent.y))

	opts.Filter = s.stateCurrent.filter

	if s.stateCurrent.color != nil {
		opts.ColorM = s.colorToColorM(s.stateCurrent.color)
	}

	return opts
}

func (s *ebitenSurface) handleStateEffect(opts *ebiten.DrawImageOptions) {
	switch s.stateCurrent.effect {
	case d2enum.DrawEffectPctTransparency25:
		opts.ColorM.Translate(0, 0, 0, -transparency25)
	case d2enum.DrawEffectPctTransparency50:
		opts.ColorM.Translate(0, 0, 0, -transparency50)
	case d2enum.DrawEffectPctTransparency75:
		opts.ColorM.Translate(0, 0, 0, -transparency75)
	case d2enum.DrawEffectModulate:
		opts.CompositeMode = ebiten.CompositeModeLighter
	// https://github.com/OpenDiablo2/OpenDiablo2/issues/822
	case d2enum.DrawEffectBurn:
	case d2enum.DrawEffectNormal:
	case d2enum.DrawEffectMod2XTrans:
	case d2enum.DrawEffectMod2X:
	case d2enum.DrawEffectNone:
		opts.CompositeMode = ebiten.CompositeModeSourceOver
	}
}

// DrawTextf renders the string to the surface with the given format string and a set of parameters
func (s *ebitenSurface) DrawTextf(format string, params ...interface{}) {
	str := fmt.Sprintf(format, params...)
	s.Renderer().PrintAt(s.image, str, s.stateCurrent.x, s.stateCurrent.y)
}

// DrawLine draws a line
func (s *ebitenSurface) DrawLine(x, y int, fillColor color.Color) {
	ebitenutil.DrawLine(
		s.image,
		float64(s.stateCurrent.x),
		float64(s.stateCurrent.y),
		float64(s.stateCurrent.x+x),
		float64(s.stateCurrent.y+y),
		fillColor,
	)
}

// DrawRect draws a rectangle
func (s *ebitenSurface) DrawRect(width, height int, fillColor color.Color) {
	ebitenutil.DrawRect(
		s.image,
		float64(s.stateCurrent.x),
		float64(s.stateCurrent.y),
		float64(width),
		float64(height),
		fillColor,
	)
}

// Clear clears the entire surface, filling with the given color
func (s *ebitenSurface) Clear(fillColor color.Color) {
	s.image.Fill(fillColor)
}

// GetSize gets the size of the surface
func (s *ebitenSurface) GetSize() (x, y int) {
	return s.image.Size()
}

// GetDepth returns the depth of this surface in the stack
func (s *ebitenSurface) GetDepth() int {
	return len(s.stateStack)
}

// ReplacePixels replaces pixels in the surface with the given pixels
func (s *ebitenSurface) ReplacePixels(pixels []byte) {
	s.image.ReplacePixels(pixels)
}

// Screenshot returns an *image.RGBA of the surface
func (s *ebitenSurface) Screenshot() *image.RGBA {
	width, height := s.GetSize()
	bounds := image.Rectangle{Min: image.Point{X: 0, Y: 0}, Max: image.Point{X: width, Y: height}}
	rgba := image.NewRGBA(bounds)

	for y := 0; y < height; y++ {
		for x := 0; x < width; x++ {
			rgba.Set(x, y, s.image.At(x, y))
		}
	}

	return rgba
}

func (s *ebitenSurface) now() int64 {
	s.monotonicClock++
	return s.monotonicClock
}

// colorToColorM converts a normal color to a color matrix
func (s *ebitenSurface) colorToColorM(clr color.Color) ebiten.ColorM {
	// RGBA() is in [0 - 0xffff]. Adjust them in [0 - 0xff].
	cr, cg, cb, ca := clr.RGBA()
	cr >>= 8
	cg >>= 8
	cb >>= 8
	ca >>= 8

	if ca == 0 {
		emptyColorM := ebiten.ColorM{}
		emptyColorM.Scale(0, 0, 0, 0)

		return emptyColorM
	}

	// nolint:gomnd // byte values
	key := colorMCacheKey(cr | (cg << 8) | (cb << 16) | (ca << 24))
	e, ok := s.colorMCache[key]

	if ok {
		e.atime = s.now()
		return e.colorMatrix
	}

	if len(s.colorMCache) > cacheLimit {
		oldest := int64(math.MaxInt64)
		oldestKey := colorMCacheKey(0)

		for key, c := range s.colorMCache {
			if c.atime < oldest {
				oldestKey = key
				oldest = c.atime
			}
		}

		delete(s.colorMCache, oldestKey)
	}

	cm := ebiten.ColorM{}
	rf := float64(cr) / float64(ca)
	gf := float64(cg) / float64(ca)
	bf := float64(cb) / float64(ca)
	af := float64(ca) / maxAlpha
	cm.Scale(rf, gf, bf, af)

	e = &colorMCacheEntry{
		colorMatrix: cm,
		atime:       s.now(),
	}

	s.colorMCache[key] = e

	return e.colorMatrix
}
package d2gamescreen

import (
	"image"

	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2hero"

	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2inventory"

	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2enum"
	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2interface"
	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2resource"
	"github.com/OpenDiablo2/OpenDiablo2/d2common/d2util"
	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2asset"
	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2screen"
	"github.com/OpenDiablo2/OpenDiablo2/d2core/d2ui"
	"github.com/OpenDiablo2/OpenDiablo2/d2networking/d2client/d2clientconnectiontype"
)

const (
	millisecondsPerSecond = 1000.0
)

type heroRenderConfig struct {
	idleAnimationPath               string
	idleSelectedAnimationPath       string
	forwardWalkAnimationPath        string
	forwardWalkOverlayAnimationPath string
	forwardWalkOverlayBlend         bool
	selectedAnimationPath           string
	selectedOverlayAnimationPath    string
	backWalkAnimationPath           string
	backWalkOverlayAnimationPath    string
	selectionBounds                 image.Rectangle
	selectSfx                       string
	deselectSfx                     string
	position                        image.Point
	idlePlayLengthMs                int
	forwardWalkPlayLengthMs         int
	backWalkPlayLengthMs            int
}

func point(x, y int) image.Point {
	return image.Point{X: x, Y: y}
}

func rect(x1, y1, x2, y2 int) image.Rectangle {
	return image.Rectangle{Min: point(x1, y1), Max: point(x2, y2)}
}

// animation position, selection box bound, animation play lengths in ms
const (
	barbPosX, barbPosY                                     = 400, 330
	barbRectMinX, barbRectMinY, barbRectMaxX, barbRectMaxY = 364, 201, 90, 170
	barbIdleLength, barbForwardLength, barbBackLength      = 0, 2500, 1000

	sorcPosX, sorcPosY                                     = 626, 352
	sorcRectMinX, sorcRectMinY, sorcRectMaxX, sorcRectMaxY = 580, 240, 65, 160
	sorcIdleLength, sorcForwardLength, sorcBackLength      = 2500, 2300, 1200

	necPosX, necPosY                                   = 300, 335
	necRectMinX, necRectMinY, necRectMaxX, necRectMaxY = 265, 220, 55, 175
	necIdleLength, necForwardLength, necBackLength     = 1200, 2000, 1500

	palPosX, palPosY                                   = 521, 338
	palRectMinX, palRectMinY, palRectMaxX, palRectMaxY = 490, 210, 65, 180
	palIdleLength, palForwardLength, palBackLength     = 2500, 3400, 1300

	amaPosX, amaPosY                                   = 100, 339
	amaRectMinX, amaRectMinY, amaRectMaxX, amaRectMaxY = 70, 220, 55, 200
	amaIdleLength, amaForwardLength, amaBackLength     = 2500, 2200, 1500

	assPosX, assPosY                                   = 231, 365
	assRectMinX, assRectMinY, assRectMaxX, assRectMaxY = 175, 235, 50, 180
	assIdleLength, assForwardLength, assBackLength     = 2500, 3800, 1500

	druPosX, druPosY                                   = 720, 370
	druRectMinX, druRectMinY, druRectMaxX, druRectMaxY = 680, 220, 70, 195
	druIdleLength, druForwardLength, druBackLength     = 1500, 4800, 1500

	campfirePosX, campfirePosY = 380, 335
)

// label and button positions
const (
	headingX, headingY               = 400, 17
	heroClassLabelX, heroClassLabelY = 400, 65
	heroDescLine1X, heroDescLine1Y   = 400, 100
	heroDescLine2X, heroDescLine2Y   = 400, 115
	heroDescLine3X, heroDescLine3Y   = 400, 130
	heroNameLabelX, heroNameLabelY   = 321, 475
	expansionLabelX, expansionLabelY = 339, 526
	hardcoreLabelX, hardcoreLabelY   = 339, 548

	selHeroExitBtnX, selHeroExitBtnY = 33, 537
	selHeroOkBtnX, selHeroOkBtnY     = 630, 537

	heroNameTextBoxX, heoNameTextBoxY       = 318, 493
	expandsionCheckboxX, expansionCheckboxY = 318, 526
	hardcoreCheckoxX, hardcoreCheckboxY     = 318, 548
)

const heroDescCharWidth = 37

//nolint:funlen // this func returns a map of structs and the structs are big, deal with it
func getHeroRenderConfiguration() map[d2enum.Hero]*heroRenderConfig {
	configs := make(map[d2enum.Hero]*heroRenderConfig)

	configs[d2enum.HeroBarbarian] = &heroRenderConfig{
		d2resource.CharacterSelectBarbarianUnselected,
		d2resource.CharacterSelectBarbarianUnselectedH,
		d2resource.CharacterSelectBarbarianForwardWalk,
		d2resource.CharacterSelectBarbarianForwardWalkOverlay,
		false,
		d2resource.CharacterSelectBarbarianSelected,
		"",
		d2resource.CharacterSelectBarbarianBackWalk,
		"",
		rect(barbRectMinX, barbRectMinY, barbRectMaxX, barbRectMaxY),
		d2resource.SFXBarbarianSelect,
		d2resource.SFXBarbarianDeselect,
		point(barbPosX, barbPosY),
		barbIdleLength,
		barbForwardLength,
		barbBackLength,
	}

	configs[d2enum.HeroSorceress] = &heroRenderConfig{
		d2resource.CharacterSelectSorceressUnselected,
		d2resource.CharacterSelectSorceressUnselectedH,
		d2resource.CharacterSelectSorceressForwardWalk,
		d2resource.CharacterSelectSorceressForwardWalkOverlay,
		true,
		d2resource.CharacterSelectSorceressSelected,
		d2resource.CharacterSelectSorceressSelectedOverlay,
		d2resource.CharacterSelectSorceressBackWalk,
		d2resource.CharacterSelectSorceressBackWalkOverlay,
		rect(sorcRectMinX, sorcRectMinY, sorcRectMaxX, sorcRectMaxY),
		d2resource.SFXSorceressSelect,
		d2resource.SFXSorceressDeselect,
		point(sorcPosX, sorcPosY),
		sorcIdleLength,
		sorcForwardLength,
		sorcBackLength,
	}

	configs[d2enum.HeroNecromancer] = &heroRenderConfig{
		d2resource.CharacterSelectNecromancerUnselected,
		d2resource.CharacterSelectNecromancerUnselectedH,
		d2resource.CharacterSelectNecromancerForwardWalk,
		d2resource.CharacterSelectNecromancerForwardWalkOverlay,
		true,
		d2resource.CharacterSelectNecromancerSelected,
		d2resource.CharacterSelectNecromancerSelectedOverlay,
		d2resource.CharacterSelectNecromancerBackWalk,
		d2resource.CharacterSelectNecromancerBackWalkOverlay,
		rect(necRectMinX, necRectMinY, necRectMaxX, necRectMaxY),
		d2resource.SFXNecromancerSelect,
		d2resource.SFXNecromancerDeselect,
		point(necPosX, necPosY),
		necIdleLength,
		necForwardLength,
		necBackLength,
	}

	configs[d2enum.HeroPaladin] = &heroRenderConfig{
		d2resource.CharacterSelectPaladinUnselected,
		d2resource.CharacterSelectPaladinUnselectedH,
		d2resource.CharacterSelectPaladinForwardWalk,
		d2resource.CharacterSelectPaladinForwardWalkOverlay,
		false,
		d2resource.CharacterSelectPaladinSelected,
		"",
		d2resource.CharacterSelectPaladinBackWalk,
		"",
		rect(palRectMinX, palRectMinY, palRectMaxX, palRectMaxY),
		d2resource.SFXPaladinSelect,
		d2resource.SFXPaladinDeselect,
		point(palPosX, palPosY),
		palIdleLength,
		palForwardLength,
		palBackLength,
	}

	configs[d2enum.HeroAmazon] = &heroRenderConfig{
		d2resource.CharacterSelectAmazonUnselected,
		d2resource.CharacterSelectAmazonUnselectedH,
		d2resource.CharacterSelectAmazonForwardWalk,
		"",
		false,
		d2resource.CharacterSelectAmazonSelected,
		"",
		d2resource.CharacterSelectAmazonBackWalk,
		"",
		rect(amaRectMinX, amaRectMinY, amaRectMaxX, amaRectMaxY),
		d2resource.SFXAmazonSelect,
		d2resource.SFXAmazonDeselect,
		point(amaPosX, amaPosY),
		amaIdleLength,
		amaForwardLength,
		amaBackLength,
	}

	configs[d2enum.HeroAssassin] = &heroRenderConfig{
		d2resource.CharacterSelectAssassinUnselected,
		d2resource.CharacterSelectAssassinUnselectedH,
		d2resource.CharacterSelectAssassinForwardWalk,
		"",
		false,
		d2resource.CharacterSelectAssassinSelected,
		"",
		d2resource.CharacterSelectAssassinBackWalk,
		"",
		rect(assRectMinX, assRectMinY, assRectMaxX, assRectMaxY),
		d2resource.SFXAssassinSelect,
		d2resource.SFXAssassinDeselect,
		point(assPosX, assPosY),
		assIdleLength,
		assForwardLength,
		assBackLength,
	}

	configs[d2enum.HeroDruid] = &heroRenderConfig{
		d2resource.CharacterSelectDruidUnselected,
		d2resource.CharacterSelectDruidUnselectedH,
		d2resource.CharacterSelectDruidForwardWalk,
		"",
		false,
		d2resource.CharacterSelectDruidSelected,
		"",
		d2resource.CharacterSelectDruidBackWalk,
		"",
		rect(druRectMinX, druRectMinY, druRectMaxX, druRectMaxY),
		d2resource.SFXDruidSelect,
		d2resource.SFXDruidDeselect,
		point(druPosX, druPosY),
		druIdleLength,
		druForwardLength,
		druBackLength,
	}

	return configs
}

// HeroRenderInfo stores the rendering information of a hero for the Select Hero Class screen
type HeroRenderInfo struct {
	Stance                   d2enum.HeroStance
	IdleSprite               *d2ui.Sprite
	IdleSelectedSprite       *d2ui.Sprite
	ForwardWalkSprite        *d2ui.Sprite
	ForwardWalkSpriteOverlay *d2ui.Sprite
	SelectedSprite           *d2ui.Sprite
	SelectedSpriteOverlay    *d2ui.Sprite
	BackWalkSprite           *d2ui.Sprite
	BackWalkSpriteOverlay    *d2ui.Sprite
	SelectionBounds          image.Rectangle
	SelectSfx                d2interface.SoundEffect
	DeselectSfx              d2interface.SoundEffect
	shc                      *SelectHeroClass
}

func (hri *HeroRenderInfo) advance(elapsed float64) {
	advanceSprite(hri.shc, hri.IdleSprite, elapsed)
	advanceSprite(hri.shc, hri.IdleSelectedSprite, elapsed)
	advanceSprite(hri.shc, hri.ForwardWalkSprite, elapsed)
	advanceSprite(hri.shc, hri.ForwardWalkSpriteOverlay, elapsed)
	advanceSprite(hri.shc, hri.SelectedSprite, elapsed)
	advanceSprite(hri.shc, hri.SelectedSpriteOverlay, elapsed)
	advanceSprite(hri.shc, hri.BackWalkSprite, elapsed)
	advanceSprite(hri.shc, hri.BackWalkSpriteOverlay, elapsed)
}

// CreateSelectHeroClass creates an instance of a SelectHeroClass
func CreateSelectHeroClass(
	navigator d2interface.Navigator,
	asset *d2asset.AssetManager,
	renderer d2interface.Renderer,
	audioProvider d2interface.AudioProvider,
	ui *d2ui.UIManager,
	connectionType d2clientconnectiontype.ClientConnectionType,
	l d2util.LogLevel,
	connectionHost string,
) (*SelectHeroClass, error) {
	playerStateFactory, err := d2hero.NewHeroStateFactory(asset)
	if err != nil {
		return nil, err
	}

	inventoryItemFactory, err := d2inventory.NewInventoryItemFactory(asset)
	if err != nil {
		return nil, err
	}

	selectHeroClass := &SelectHeroClass{
		asset:                asset,
		heroRenderInfo:       make(map[d2enum.Hero]*HeroRenderInfo),
		selectedHero:         d2enum.HeroNone,
		connectionType:       connectionType,
		connectionHost:       connectionHost,
		audioProvider:        audioProvider,
		renderer:             renderer,
		navigator:            navigator,
		uiManager:            ui,
		HeroStateFactory:     playerStateFactory,
		InventoryItemFactory: inventoryItemFactory,
	}

	selectHeroClass.Logger = d2util.NewLogger()
	selectHeroClass.Logger.SetLevel(l)
	selectHeroClass.Logger.SetPrefix(logPrefix)

	return selectHeroClass, nil
}

// SelectHeroClass represents the Select Hero Class screen
type SelectHeroClass struct {
	asset           *d2asset.AssetManager
	uiManager       *d2ui.UIManager
	bgImage         *d2ui.Sprite
	campfire        *d2ui.Sprite
	headingLabel    *d2ui.Label
	heroClassLabel  *d2ui.Label
	heroDesc1Label  *d2ui.Label
	heroDesc2Label  *d2ui.Label
	heroDesc3Label  *d2ui.Label
	heroNameTextbox *d2ui.TextBox
	heroNameLabel   *d2ui.Label
	heroRenderInfo  map[d2enum.Hero]*HeroRenderInfo
	*d2inventory.InventoryItemFactory
	*d2hero.HeroStateFactory
	selectedHero       d2enum.Hero
	exitButton         *d2ui.Button
	okButton           *d2ui.Button
	expansionCheckbox  *d2ui.Checkbox
	expansionCharLabel *d2ui.Label
	hardcoreCheckbox   *d2ui.Checkbox
	hardcoreCharLabel  *d2ui.Label
	connectionType     d2clientconnectiontype.ClientConnectionType
	connectionHost     string

	audioProvider d2interface.AudioProvider
	renderer      d2interface.Renderer
	navigator     d2interface.Navigator

	*d2util.Logger
}

// OnLoad loads the resources for the Select Hero Class screen
func (v *SelectHeroClass) OnLoad(loading d2screen.LoadingState) {
	v.audioProvider.PlayBGM(d2resource.BGMTitle)
	loading.Progress(tenPercent)

	v.bgImage = v.loadSprite(
		d2resource.CharacterSelectBackground,
		point(0, 0),
		0,
		true,
		false,
	)

	loading.Progress(thirtyPercent)

	v.createLabels()
	loading.Progress(fourtyPercent)
	v.createButtons()

	v.campfire = v.loadSprite(
		d2resource.CharacterSelectCampfire,
		point(campfirePosX, campfirePosY),
		0,
		true,
		true,
	)

	v.createCheckboxes()
	loading.Progress(fiftyPercent)

	for hero, config := range getHeroRenderConfiguration() {
		position := config.position
		forwardWalkOverlaySprite := v.loadSprite(
			config.forwardWalkOverlayAnimationPath,
			position,
			config.forwardWalkPlayLengthMs,
			false,
			config.forwardWalkOverlayBlend,
		)
		v.heroRenderInfo[hero] = &HeroRenderInfo{
			Stance: d2enum.HeroStanceIdle,
			IdleSprite: v.loadSprite(config.idleAnimationPath, position,
				config.idlePlayLengthMs, true, false),
			IdleSelectedSprite: v.loadSprite(config.idleSelectedAnimationPath,
				position,
				config.idlePlayLengthMs, true, false),
			ForwardWalkSprite: v.loadSprite(config.forwardWalkAnimationPath, position,
				config.forwardWalkPlayLengthMs, false, false),
			ForwardWalkSpriteOverlay: forwardWalkOverlaySprite,
			SelectedSprite: v.loadSprite(config.selectedAnimationPath, position,
				config.idlePlayLengthMs, true, false),
			SelectedSpriteOverlay: v.loadSprite(config.selectedOverlayAnimationPath, position,
				config.idlePlayLengthMs, true, true),
			BackWalkSprite: v.loadSprite(config.backWalkAnimationPath, position,
				config.backWalkPlayLengthMs, false, false),
			BackWalkSpriteOverlay: v.loadSprite(config.backWalkOverlayAnimationPath, position,
				config.backWalkPlayLengthMs, false, true),
			SelectionBounds: config.selectionBounds,
			SelectSfx:       v.loadSoundEffect(config.selectSfx),
			DeselectSfx:     v.loadSoundEffect(config.deselectSfx),
		}
	}
}

func (v *SelectHeroClass) createLabels() {
	v.headingLabel = v.uiManager.NewLabel(d2resource.Font30, d2resource.PaletteUnits)
	fontWidth, _ := v.headingLabel.GetSize()
	half := 2
	halfFontWidth := fontWidth / half

	v.headingLabel.SetPosition(headingX-halfFontWidth, headingY)
	v.headingLabel.SetText(v.asset.TranslateString(d2enum.SelectHeroClassLabel))
	v.headingLabel.Alignment = d2ui.HorizontalAlignCenter

	v.heroClassLabel = v.uiManager.NewLabel(d2resource.Font30, d2resource.PaletteUnits)
	v.heroClassLabel.Alignment = d2ui.HorizontalAlignCenter
	v.heroClassLabel.SetPosition(heroClassLabelX, heroClassLabelY)

	v.heroDesc1Label = v.uiManager.NewLabel(d2resource.Font16, d2resource.PaletteUnits)
	v.heroDesc1Label.Alignment = d2ui.HorizontalAlignCenter
	v.heroDesc1Label.SetPosition(heroDescLine1X, heroDescLine1Y)

	v.heroDesc2Label = v.uiManager.NewLabel(d2resource.Font16, d2resource.PaletteUnits)
	v.heroDesc2Label.Alignment = d2ui.HorizontalAlignCenter
	v.heroDesc2Label.SetPosition(heroDescLine2X, heroDescLine2Y)

	v.heroDesc3Label = v.uiManager.NewLabel(d2resource.Font16, d2resource.PaletteUnits)
	v.heroDesc3Label.Alignment = d2ui.HorizontalAlignCenter
	v.heroDesc3Label.SetPosition(heroDescLine3X, heroDescLine3Y)

	v.heroNameLabel = v.uiManager.NewLabel(d2resource.Font16, d2resource.PaletteUnits)
	v.heroNameLabel.Alignment = d2ui.HorizontalAlignLeft
	v.heroNameLabel.SetText(d2ui.ColorTokenize(v.asset.TranslateString(d2enum.CharNameLabel), d2ui.ColorTokenGold))
	v.heroNameLabel.SetPosition(heroNameLabelX, heroNameLabelY)

	v.expansionCharLabel = v.uiManager.NewLabel(d2resource.Font16, d2resource.PaletteUnits)
	v.expansionCharLabel.Alignment = d2ui.HorizontalAlignLeft
	v.expansionCharLabel.SetText(d2ui.ColorTokenize(v.asset.TranslateString("#803"), d2ui.ColorTokenGold))
	v.expansionCharLabel.SetPosition(expansionLabelX, expansionLabelY)

	v.hardcoreCharLabel = v.uiManager.NewLabel(d2resource.Font16, d2resource.PaletteUnits)
	v.hardcoreCharLabel.Alignment = d2ui.HorizontalAlignLeft
	v.hardcoreCharLabel.SetText(d2ui.ColorTokenize(v.asset.TranslateString(d2enum.HardCoreLabel), d2ui.ColorTokenGold))
	v.hardcoreCharLabel.SetPosition(hardcoreLabelX, hardcoreLabelY)
}

func (v *SelectHeroClass) createButtons() {
	v.exitButton = v.uiManager.NewButton(d2ui.ButtonTypeMedium, v.asset.TranslateString(d2enum.ExitLabel))
	v.exitButton.SetPosition(selHeroExitBtnX, selHeroExitBtnY)
	v.exitButton.OnActivated(func() { v.onExitButtonClicked() })

	v.okButton = v.uiManager.NewButton(d2ui.ButtonTypeMedium, v.asset.TranslateString(d2enum.OKLabel))
	v.okButton.SetPosition(selHeroOkBtnX, selHeroOkBtnY)
	v.okButton.OnActivated(func() { v.onOkButtonClicked() })
	v.okButton.SetVisible(false)
	v.okButton.SetEnabled(false)
}

func (v *SelectHeroClass) createCheckboxes() {
	v.heroNameTextbox = v.uiManager.NewTextbox()
	v.heroNameTextbox.SetPosition(heroNameTextBoxX, heoNameTextBoxY)
	v.heroNameTextbox.SetVisible(false)

	v.expansionCheckbox = v.uiManager.NewCheckbox(true)
	v.expansionCheckbox.SetPosition(expandsionCheckboxX, expansionCheckboxY)
	v.expansionCheckbox.SetVisible(false)

	v.hardcoreCheckbox = v.uiManager.NewCheckbox(false)
	v.hardcoreCheckbox.SetPosition(hardcoreCheckoxX, hardcoreCheckboxY)
	v.hardcoreCheckbox.SetVisible(false)
}

// OnUnload releases the resources of the Select Hero Class screen
func (v *SelectHeroClass) OnUnload() error {
	for i := range v.heroRenderInfo {
		v.heroRenderInfo[i].SelectSfx.Stop()
		v.heroRenderInfo[i].DeselectSfx.Stop()
	}

	v.heroRenderInfo = nil

	return nil
}

func (v *SelectHeroClass) onExitButtonClicked() {
	v.navigator.ToCharacterSelect(v.connectionType, v.connectionHost)
}

func (v *SelectHeroClass) onOkButtonClicked() {
	heroName := v.heroNameTextbox.GetText()
	defaultStats := v.asset.Records.Character.Stats[v.selectedHero]
	statsState := v.CreateHeroStatsState(v.selectedHero, defaultStats)

	playerState, err := v.CreateHeroState(heroName, v.selectedHero, statsState)
	if err != nil {
		v.Errorf("failed to create hero state!, err: %v", err.Error())
		return
	}

	err = v.Save(playerState)
	if err != nil {
		v.Errorf("failed to save game state!, err: %v", err.Error())
		return
	}

	playerState.Equipment = v.InventoryItemFactory.DefaultHeroItems[v.selectedHero]
	v.navigator.ToCreateGame(playerState.FilePath, v.connectionType, v.connectionHost)
}

// Render renders the Select Hero Class screen
func (v *SelectHeroClass) Render(screen d2interface.Surface) {
	v.bgImage.RenderSegmented(screen, 4, 3, 0)
	v.headingLabel.Render(screen)

	for heroClass, heroInfo := range v.heroRenderInfo {
		if heroInfo.Stance == d2enum.HeroStanceIdle || heroInfo.Stance == d2enum.HeroStanceIdleSelected {
			v.renderHero(screen, heroClass)
		}
	}

	for heroClass, heroInfo := range v.heroRenderInfo {
		if heroInfo.Stance != d2enum.HeroStanceIdle && heroInfo.Stance != d2enum.HeroStanceIdleSelected {
			v.renderHero(screen, heroClass)
		}
	}

	if v.selectedHero != d2enum.HeroNone {
		v.heroClassLabel.Render(screen)
		v.heroDesc1Label.Render(screen)
		v.heroDesc2Label.Render(screen)
		v.heroDesc3Label.Render(screen)
	}

	v.campfire.Render(screen)

	if v.heroNameTextbox.GetVisible() {
		v.heroNameLabel.Render(screen)
		v.expansionCharLabel.Render(screen)
		v.hardcoreCharLabel.Render(screen)
	}
}

// Advance runs the update logic on the Select Hero Class screen
func (v *SelectHeroClass) Advance(tickTime float64) error {
	canSelect := true

	if err := v.campfire.Advance(tickTime); err != nil {
		return err
	}

	for infoIdx := range v.heroRenderInfo {
		v.heroRenderInfo[infoIdx].advance(tickTime)

		if v.heroRenderInfo[infoIdx].Stance != d2enum.HeroStanceIdle &&
			v.heroRenderInfo[infoIdx].Stance != d2enum.HeroStanceIdleSelected &&
			v.heroRenderInfo[infoIdx].Stance != d2enum.HeroStanceSelected {
			canSelect = false
		}
	}

	for heroType := range v.heroRenderInfo {
		v.updateHeroSelectionHover(heroType, canSelect)
	}

	v.okButton.SetEnabled(len(v.heroNameTextbox.GetText()) >= 2 && v.selectedHero != d2enum.HeroNone)

	return nil
}

func (v *SelectHeroClass) updateHeroSelectionHover(hero d2enum.Hero, canSelect bool) {
	renderInfo := v.heroRenderInfo[hero]
	switch renderInfo.Stance {
	case d2enum.HeroStanceApproaching:
		if renderInfo.ForwardWalkSprite.IsOnLastFrame() {
			renderInfo.Stance = d2enum.HeroStanceSelected
			setSpriteToFirstFrame(renderInfo.SelectedSprite)
			setSpriteToFirstFrame(renderInfo.SelectedSpriteOverlay)
		}

		return
	case d2enum.HeroStanceRetreating:
		if renderInfo.BackWalkSprite.IsOnLastFrame() {
			renderInfo.Stance = d2enum.HeroStanceIdle
			setSpriteToFirstFrame(renderInfo.IdleSprite)
		}

		return
	}

	if !canSelect || renderInfo.Stance == d2enum.HeroStanceSelected {
		return
	}

	mouseX, mouseY := v.uiManager.CursorPosition()
	b := renderInfo.SelectionBounds
	mouseHover := (mouseX >= b.Min.X) && (mouseX <= b.Min.X+b.Max.X) && (mouseY >= b.Min.Y) && (mouseY <= b.Min.Y+b.Max.Y)

	if mouseHover && v.uiManager.CursorButtonPressed(d2ui.CursorButtonLeft) {
		v.handleCursorButtonPress(hero, renderInfo)
		return
	}

	v.setCurrentFrame(mouseHover, renderInfo)

	if v.selectedHero == d2enum.HeroNone && mouseHover {
		v.selectedHero = hero
		v.updateHeroText()
	}
}

func (v *SelectHeroClass) handleCursorButtonPress(hero d2enum.Hero, renderInfo *HeroRenderInfo) {
	v.heroNameTextbox.SetVisible(true)
	v.heroNameTextbox.Activate()
	v.okButton.SetVisible(true)
	v.expansionCheckbox.SetVisible(true)
	v.hardcoreCheckbox.SetVisible(true)

	renderInfo.Stance = d2enum.HeroStanceApproaching
	setSpriteToFirstFrame(renderInfo.ForwardWalkSprite)
	setSpriteToFirstFrame(renderInfo.ForwardWalkSpriteOverlay)

	for _, heroInfo := range v.heroRenderInfo {
		if heroInfo.Stance != d2enum.HeroStanceSelected {
			continue
		}

		heroInfo.SelectSfx.Stop()
		heroInfo.DeselectSfx.Play()
		heroInfo.Stance = d2enum.HeroStanceRetreating
		setSpriteToFirstFrame(heroInfo.BackWalkSprite)
		setSpriteToFirstFrame(heroInfo.BackWalkSpriteOverlay)
	}

	v.selectedHero = hero
	v.updateHeroText()
	renderInfo.SelectSfx.Play()
}

func (v *SelectHeroClass) setCurrentFrame(mouseHover bool, renderInfo *HeroRenderInfo) {
	if mouseHover && renderInfo.Stance != d2enum.HeroStanceIdleSelected {
		if err := renderInfo.IdleSelectedSprite.SetCurrentFrame(renderInfo.IdleSprite.GetCurrentFrame()); err != nil {
			v.Errorf("could not set current frame to: %d\n", renderInfo.IdleSprite.GetCurrentFrame())
		}

		renderInfo.Stance = d2enum.HeroStanceIdleSelected
	} else if !mouseHover && renderInfo.Stance != d2enum.HeroStanceIdle {
		if err := renderInfo.IdleSprite.SetCurrentFrame(renderInfo.IdleSelectedSprite.GetCurrentFrame()); err != nil {
			v.Errorf("could not set current frame to: %d\n", renderInfo.IdleSelectedSprite.GetCurrentFrame())
		}

		renderInfo.Stance = d2enum.HeroStanceIdle
	}
}

func (v *SelectHeroClass) renderHero(screen d2interface.Surface, hero d2enum.Hero) {
	renderInfo := v.heroRenderInfo[hero]
	switch renderInfo.Stance {
	case d2enum.HeroStanceIdle:
		drawSprite(renderInfo.IdleSprite, screen)
	case d2enum.HeroStanceIdleSelected:
		drawSprite(renderInfo.IdleSelectedSprite, screen)
	case d2enum.HeroStanceApproaching:
		drawSprite(renderInfo.ForwardWalkSprite, screen)
		drawSprite(renderInfo.ForwardWalkSpriteOverlay, screen)
	case d2enum.HeroStanceSelected:
		drawSprite(renderInfo.SelectedSprite, screen)
		drawSprite(renderInfo.SelectedSpriteOverlay, screen)
	case d2enum.HeroStanceRetreating:
		drawSprite(renderInfo.BackWalkSprite, screen)
		drawSprite(renderInfo.BackWalkSpriteOverlay, screen)
	}
}

func (v *SelectHeroClass) updateHeroText() {
	// v.setDescLabels("") really takes a string translation key, but temporarily disabled.
	switch v.selectedHero {
	case d2enum.HeroNone:
		return
	case d2enum.HeroBarbarian:
		v.heroClassLabel.SetText(v.asset.TranslateString("partycharbar"))
		v.setDescLabels(d2enum.BarbarianDescr, "")
	case d2enum.HeroNecromancer:
		v.heroClassLabel.SetText(v.asset.TranslateString("partycharnec"))
		v.setDescLabels(d2enum.NecromancerDescr, "")
	case d2enum.HeroPaladin:
		v.heroClassLabel.SetText(v.asset.TranslateString("partycharpal"))
		v.setDescLabels(d2enum.PaladinDescr, "")
	case d2enum.HeroAssassin:
		v.heroClassLabel.SetText(v.asset.TranslateString("partycharass"))
		v.setDescLabels(0, "#305")
	case d2enum.HeroSorceress:
		v.heroClassLabel.SetText(v.asset.TranslateString("partycharsor"))
		v.setDescLabels(d2enum.SorceressDescr, "")
	case d2enum.HeroAmazon:
		v.heroClassLabel.SetText(v.asset.TranslateString("partycharama"))
		v.setDescLabels(d2enum.AmazonDescr, "")
	case d2enum.HeroDruid:
		v.heroClassLabel.SetText(v.asset.TranslateString("partychardru"))
		// here is a problem with polish language: in polish string table, there are two items with key "#304"
		v.setDescLabels(0, "#304")
	}
}

const (
	oneLine = 1
	twoLine = 2
)

func (v *SelectHeroClass) setDescLabels(descKey int, key string) {
	var heroDesc string

	if key != "" {
		heroDesc = v.asset.TranslateString(key)
	} else {
		heroDesc = v.asset.TranslateString(descKey)
	}

	parts := d2util.SplitIntoLinesWithMaxWidth(heroDesc, heroDescCharWidth)

	numLines := len(parts)

	if numLines > oneLine {
		v.heroDesc1Label.SetText(parts[0])
		v.heroDesc2Label.SetText(parts[1])
	} else {
		v.heroDesc1Label.SetText("")
		v.heroDesc2Label.SetText("")
	}

	if numLines > twoLine {
		v.heroDesc3Label.SetText(parts[2])
	} else {
		v.heroDesc3Label.SetText("")
	}
}

func setSpriteToFirstFrame(sprite *d2ui.Sprite) {
	if sprite != nil {
		sprite.Rewind()
	}
}

func drawSprite(sprite *d2ui.Sprite, target d2interface.Surface) {
	if sprite != nil {
		sprite.Render(target)
	}
}

func advanceSprite(v *SelectHeroClass, sprite *d2ui.Sprite, elapsed float64) {
	if sprite != nil {
		if err := sprite.Advance(elapsed); err != nil {
			v.Error("could not advance the sprite:" + err.Error())
		}
	}
}

func (v *SelectHeroClass) loadSprite(animationPath string, position image.Point,
	playLength int,
	playLoop,
	blend bool) *d2ui.Sprite {
	if animationPath == "" {
		return nil
	}

	sprite, err := v.uiManager.NewSprite(animationPath, d2resource.PaletteFechar)
	if err != nil {
		v.Error("could not load sprite for the animation: %s\n" + animationPath + "with error: " + err.Error())
		return nil
	}

	sprite.PlayForward()
	sprite.SetPlayLoop(playLoop)

	if blend {
		sprite.SetEffect(d2enum.DrawEffectModulate)
	}

	if playLength != 0 {
		sprite.SetPlayLength(float64(playLength) / millisecondsPerSecond)
	}

	sprite.SetPosition(position.X, position.Y)

	return sprite
}

func (v *SelectHeroClass) loadSoundEffect(sfx string) d2interface.SoundEffect {
	result, err := v.audioProvider.LoadSound(sfx, false, false)
	if err != nil {
		v.Error(err.Error())
		return nil
	}

	return result
}


